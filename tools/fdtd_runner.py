#!/usr/bin/env python3
"""
WE-FDTD Runner Helper

Python helper to write input.dat, run WE-FDTD (subprocess/mpirun), parse wave CSV, and demo.
This module provides a lightweight integration layer for running WE-FDTD CUDA simulations
from Python without embedding CUDA code into the repository.
"""

import os
import subprocess
import sys
import csv
import numpy as np
from pathlib import Path
import tempfile
import shutil
import argparse


class FDTDRunner:
    """
    Helper class to interface with WE-FDTD CUDA simulator.
    
    This class provides methods to:
    - Generate input.dat files for WE-FDTD
    - Execute WE-FDTD via subprocess (with optional MPI support)
    - Parse receiver waveform CSV outputs
    - Manage simulation directories and cleanup
    """
    
    def __init__(self, fdtd_binary_path=None, work_dir=None, use_mpi=False, mpi_ranks=1):
        """
        Initialize FDTD runner.
        
        Args:
            fdtd_binary_path (str): Path to WE-FDTD executable
            work_dir (str): Working directory for simulations (default: temp dir)
            use_mpi (bool): Whether to use MPI for execution
            mpi_ranks (int): Number of MPI ranks if using MPI
        """
        self.fdtd_binary_path = fdtd_binary_path or "we-fdtd"
        self.work_dir = Path(work_dir) if work_dir else Path(tempfile.mkdtemp())
        self.use_mpi = use_mpi
        self.mpi_ranks = mpi_ranks
        self.simulation_results = {}
        
    def write_input_dat(self, config, output_path=None):
        """
        Write input.dat file for WE-FDTD simulation.
        
        Args:
            config (dict): Configuration parameters for the simulation
            output_path (str): Path to write input.dat (default: work_dir/input.dat)
            
        Returns:
            str: Path to the written input.dat file
        """
        if output_path is None:
            output_path = self.work_dir / "input.dat"
        
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Default configuration parameters
        default_config = {
            'domain_size_x': 1.0,
            'domain_size_y': 1.0,
            'domain_size_z': 1.0,
            'grid_points_x': 100,
            'grid_points_y': 100,
            'grid_points_z': 100,
            'time_steps': 1000,
            'dt': 1e-6,
            'source_freq': 40000.0,
            'source_x': 0.5,
            'source_y': 0.5,
            'source_z': 0.5,
            'receivers': [(0.7, 0.5, 0.5), (0.3, 0.5, 0.5)],
            'boundary_conditions': 'absorbing',
        }
        
        # Merge with provided config
        full_config = {**default_config, **config}
        
        with open(output_path, 'w') as f:
            f.write(f"# WE-FDTD Input Configuration\n")
            f.write(f"# Generated by bat_sensory FDTD integration\n\n")
            
            # Domain parameters
            f.write(f"DOMAIN_SIZE {full_config['domain_size_x']} {full_config['domain_size_y']} {full_config['domain_size_z']}\n")
            f.write(f"GRID_POINTS {full_config['grid_points_x']} {full_config['grid_points_y']} {full_config['grid_points_z']}\n")
            f.write(f"TIME_STEPS {full_config['time_steps']}\n")
            f.write(f"DT {full_config['dt']}\n")
            
            # Source parameters
            f.write(f"SOURCE_FREQ {full_config['source_freq']}\n")
            f.write(f"SOURCE_POS {full_config['source_x']} {full_config['source_y']} {full_config['source_z']}\n")
            
            # Receivers
            f.write(f"NUM_RECEIVERS {len(full_config['receivers'])}\n")
            for i, (x, y, z) in enumerate(full_config['receivers']):
                f.write(f"RECEIVER_{i} {x} {y} {z}\n")
            
            # Boundary conditions
            f.write(f"BOUNDARY {full_config['boundary_conditions']}\n")
        
        return str(output_path)
    
    def run_fdtd_simulation(self, input_dat_path, output_dir=None):
        """
        Execute WE-FDTD simulation.
        
        Args:
            input_dat_path (str): Path to input.dat file
            output_dir (str): Directory for simulation outputs
            
        Returns:
            dict: Simulation results with return code and output paths
        """
        if output_dir is None:
            output_dir = self.work_dir / "output"
        
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Prepare command
        if self.use_mpi:
            cmd = ["mpirun", "-np", str(self.mpi_ranks), self.fdtd_binary_path]
        else:
            cmd = [self.fdtd_binary_path]
        
        cmd.extend(["-i", str(input_dat_path), "-o", str(output_dir)])
        
        # Execute simulation
        try:
            result = subprocess.run(
                cmd,
                cwd=str(self.work_dir),
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            simulation_results = {
                'return_code': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'output_dir': str(output_dir),
                'success': result.returncode == 0
            }
            
            if result.returncode == 0:
                # Look for output files
                wave_files = list(output_dir.glob("*.csv"))
                simulation_results['wave_files'] = [str(f) for f in wave_files]
            
            return simulation_results
            
        except subprocess.TimeoutExpired:
            return {
                'return_code': -1,
                'stdout': '',
                'stderr': 'Simulation timed out after 300 seconds',
                'success': False
            }
        except FileNotFoundError:
            return {
                'return_code': -1,
                'stdout': '',
                'stderr': f'FDTD binary not found: {self.fdtd_binary_path}',
                'success': False
            }
    
    def parse_wave_csv(self, csv_path):
        """
        Parse receiver waveform CSV file.
        
        Args:
            csv_path (str): Path to CSV file with waveform data
            
        Returns:
            dict: Parsed waveform data with time and amplitude arrays
        """
        try:
            data = np.loadtxt(csv_path, delimiter=',', skiprows=1)
            
            if data.ndim == 1:
                # Single receiver
                time = data[:, 0] if data.shape[1] > 1 else np.arange(len(data))
                amplitude = data[:, 1] if data.shape[1] > 1 else data
                return {
                    'time': time,
                    'amplitude': amplitude,
                    'receivers': 1
                }
            else:
                # Multiple receivers
                time = data[:, 0]
                receivers = {}
                for i in range(1, data.shape[1]):
                    receivers[f'receiver_{i-1}'] = data[:, i]
                
                return {
                    'time': time,
                    'receivers': receivers,
                    'num_receivers': data.shape[1] - 1
                }
                
        except Exception as e:
            print(f"Error parsing CSV {csv_path}: {e}")
            return None
    
    def cleanup(self):
        """Clean up temporary working directory."""
        if self.work_dir.exists() and tempfile.gettempdir() in str(self.work_dir):
            shutil.rmtree(self.work_dir)


def demo_fdtd_simulation():
    """
    Demonstration of WE-FDTD integration.
    
    This function shows how to:
    1. Configure simulation parameters
    2. Write input.dat file
    3. Run FDTD simulation
    4. Parse results
    """
    print("WE-FDTD Integration Demo")
    print("=" * 40)
    
    # Create runner instance
    runner = FDTDRunner(work_dir="./fdtd_demo_run")
    
    # Define simulation configuration
    config = {
        'domain_size_x': 2.0,
        'domain_size_y': 1.0,
        'domain_size_z': 1.0,
        'grid_points_x': 200,
        'grid_points_y': 100,
        'grid_points_z': 100,
        'time_steps': 2000,
        'dt': 5e-7,
        'source_freq': 50000.0,  # 50 kHz bat call
        'source_x': 0.1,
        'source_y': 0.5,
        'source_z': 0.5,
        'receivers': [
            (1.9, 0.5, 0.5),  # Far receiver
            (0.5, 0.5, 0.5),  # Mid receiver
        ]
    }
    
    print("1. Writing input.dat file...")
    input_file = runner.write_input_dat(config)
    print(f"   Input file written to: {input_file}")
    
    print("2. Running FDTD simulation...")
    results = runner.run_fdtd_simulation(input_file)
    
    if results['success']:
        print("   Simulation completed successfully!")
        print(f"   Output directory: {results['output_dir']}")
        
        if 'wave_files' in results:
            print("3. Parsing waveform data...")
            for wave_file in results['wave_files']:
                wave_data = runner.parse_wave_csv(wave_file)
                if wave_data:
                    print(f"   Parsed {wave_file}: {len(wave_data['time'])} time steps")
    else:
        print(f"   Simulation failed: {results['stderr']}")
    
    print("\nDemo completed. Check ./fdtd_demo_run for outputs.")
    return results


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="WE-FDTD Runner Helper")
    parser.add_argument("--demo", action="store_true", help="Run demonstration")
    parser.add_argument("--fdtd-binary", help="Path to WE-FDTD binary")
    parser.add_argument("--work-dir", help="Working directory for simulations")
    parser.add_argument("--use-mpi", action="store_true", help="Use MPI for execution")
    parser.add_argument("--mpi-ranks", type=int, default=1, help="Number of MPI ranks")
    
    args = parser.parse_args()
    
    if args.demo:
        demo_fdtd_simulation()
    else:
        print("Use --demo to run demonstration, or import this module in your Python code.")
        print("Example usage:")
        print("  from tools.fdtd_runner import FDTDRunner")
        print("  runner = FDTDRunner()")
        print("  results = runner.run_fdtd_simulation('input.dat')")